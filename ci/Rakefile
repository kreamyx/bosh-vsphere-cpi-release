require 'erb'
require 'open3'
require 'time'
require 'shellwords'

# Remove did_you_mean as it's very annoying in a Rakefile
DidYouMean::Correctable.send(:remove_method, :to_s) if defined? DidYouMean

# Colorize error messages when the trace output is a TTY
module ColorizeExceptionMessageDetails
  def display_exception_message_details(ex)
    return super unless (options.trace_output || $stderr)&.isatty
    if ex.instance_of?(RuntimeError)
      trace "\e[31;01m#{ex.message}\e[0m"
    else
      trace "\e[31;01m#{ex.class.name}: \e[0m#{ex.message}"
    end
  end
end
Rake::Application.send(:prepend, ColorizeExceptionMessageDetails)

# A Concourse target as recognized by `fly`. For more information see the
# {https://concourse.ci/fly-cli.html documentation} on the `fly` CLI.
class Target
  # @return [[Target]] a list of the targets currently known to `fly`
  def self.list
    @list ||= IO.popen(%w[fly targets]).map { |t| new(*t.split(nil, 4)) }
  end

  attr_reader :name, :url, :team

  # @return [Time] the expiry time of the target's authentication token
  attr_reader :expiry

  def initialize(name, url, team, expiry)
    @name, @url, @team, @expiry = name, url, team, Time.rfc2822(expiry)
  end
end

DOCKER_NAME = ENV.fetch('DOCKER_NAME', 'vcpici/vcpi-main')

namespace :docker do
  desc 'Build a docker image from the Dockerfile'
  task(:make) { sh 'docker', 'build', '-t', DOCKER_NAME, 'docker' }

  desc "Push the docker image to '#{DOCKER_NAME}'"
  task(:push) { sh 'docker', 'push', DOCKER_NAME }

  desc "Pull the docker image from '#{DOCKER_NAME}'"
  task(:pull) { sh 'docker', 'pull', DOCKER_NAME }
end

desc "Pull, build, and push the docker image '#{DOCKER_NAME}'"
task docker: %w[docker:pull docker:make docker:push]

# Format an object for inclusion into a YAML document
#
# This actually uses `#to_json` rather than `#to_yaml` because the latter
# produces an entire YAML document. If `object` doesn't respond to
# `#to_json` then it's converted to a `String` by calling `to_s` on it
# first.
#
# @return [String] `object` formatted for inclusion into a YAML document
def e(object)
  require 'json'
  object.respond_to?(:to_json) ? object.to_json : object.to_s.to_json
end

def render(file, **kwargs)
  erb = ERB.new(File.read(file), nil, '-')
  erb.filename = file.to_s
  erb.result(binding.tap do |b|
    kwargs.each { |k, v| b.local_variable_set(k, v) }
  end)
end

class Pool
  attr_reader :name

  attr_writer :params

  def initialize(name)
    @name = name
  end

  def params
    @params ||= {}
  end

  alias to_s name
end

file 'pipeline.yml' => ['pipeline.yml.erb', 'partition.yml.erb'] do |t|
  @pool_5_5 = Pool.new('5.5')
  @pool_5_5.params = {
    RSPEC_FLAGS: "--tag ~replicate_stemcell_two_threads --tag ~vsan_datastore --tag ~nsx_vsphere --tag ~nsx_transformers --tag ~log_creds",
    NSXT_SKIP_SSL_VERIFY: "true"
  }

  @pool_6_0 = Pool.new('6.0')
  @pool_6_0.params = {
    RSPEC_FLAGS: "--tag ~nsx_vsphere --tag ~nsxt_version_two",
    NSXT_SKIP_SSL_VERIFY: "true"
  }

  @pool_6_0_nsxv = Pool.new('6.0-NSXV')
  @pool_6_0_nsxv.params = {
    RSPEC_FLAGS: "--tag nsx_vsphere"
    NSXT_SKIP_SSL_VERIFY: "true"
  }

  @pool_6_5 = Pool.new('6.5')
  @pool_6_5.params = {
    RSPEC_FLAGS: "--tag ~nsx_vsphere --tag ~disk_migration",
    NSXT_SKIP_SSL_VERIFY: "true"
  }

  @pool_6_5_nsxv = Pool.new('6.5-NSXV')
  @pool_6_5_nsxv.params = {
    RSPEC_FLAGS: "--tag nsx_vsphere"
    NSXT_SKIP_SSL_VERIFY: "true"
  }

  File.write(t.name, render(t.prerequisites.first))
end

desc 'Create or update the pipeline configuration'
task :pipeline, [:name] => 'pipeline.yml' do |t, args|
  # Default to the unexpired target expiring furthest in the future known to
  # `fly`
  CONCOURSE = ENV.fetch('CONCOURSE') do
    authorized = Target.list.select { |t| t.expiry > Time.now }
    unless target = authorized.max_by(&:expiry)
      fail 'No Concourse target specified and all targets are expired'
    end
    target.name
  end

  # Ensure that the remote host is set from DBCHOST
  DBCHOST = ENV.fetch('DBCHOST') do
    fail 'DBCHOST must be set to the unqualified hostname of your DBC host'
  end
  dbcfqdn = "#{DBCHOST}.eng.vmware.com"

  # Get the remote user name from DBCUSER, the SSH configuration for DBCHOST, or
  # the current user name
  DBCUSER = ENV.fetch('DBCUSER') do
    output, _, status = Open3.capture3('ssh', '-G', dbcfqdn)
    break nil unless status.success?
    record = output.each_line(chomp: true).map do |text|
      text.split(nil, 2)
    end.find { |option, _| option == 'user' }
    break record[1] unless record.nil?
  end || (require 'etc'; Etc.getpwuid.name)

  # Find the SSH identity file to use from the SSH configuration for DBCHOST
  output, _, status = Open3.capture3('ssh', '-G', dbcfqdn)
  fail "Unable to get SSH configuration for #{DBCHOST}" unless status.success?
  dbc_ssh_key = output.each_line(chomp: true).map do |text|
    text.split(nil, 2)
  end.find do |option, v|
    option == 'identityfile' && File.exist?(File.expand_path(v))
  end or fail "No SSH identity file available for #{DBCHOST}"
  dbc_ssh_key = File.expand_path(dbc_ssh_key[1])

  # Get the git branch name
  branch = ENV.fetch('BRANCH') { `git symbolic-ref -q --short HEAD`.strip }

  # Set the pipeline name to be vSphere-CPI when on the master branch or
  # vSphere-CPI-#{branch} when on another branch. If the branch name is
  # indeterminate (because HEAD is detached) then the pipeline name must be
  # provided as the name argument to this task.
  args.with_defaults(name: ENV.fetch('PIPELINE') do
    if branch.empty?
      fail 'Pipeline name must be specified if HEAD is detached'
    end
    branch == 'master' ? 'vSphere-CPI' : "vcpi-#{branch}"
  end)

  # Default to master if the branch name is indeterminate (because HEAD is
  # detached).
  branch = !branch.empty? ? branch : 'master'

  sh '/bin/bash', '-ec', [
    "fly -t #{CONCOURSE.shellescape} set-pipeline",
    "-p #{args.name.shellescape}",
    "-c #{t.prerequisites.first.shellescape}",
    "-v vcpi_branch=#{branch.shellescape}",
    "-v dbc_host=#{DBCHOST.shellescape}",
    "-v dbc_user=#{DBCUSER.shellescape}",
    "-v dbc_key=\"$(cat #{dbc_ssh_key.shellescape})\"",
    '-v s3_vsphere_cpi_bucket=bosh-vsphere-cpi-release',
    '-l <(secret show ~/.dot/vcpi-ci.gpg)'
  ].join(' ')
end

task default: :pipeline
